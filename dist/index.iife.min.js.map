{"version":3,"file":"index.iife.min.js","sources":["../src/store/ActionType.ts","../src/store/reducer.ts","../src/store/getInitialState.ts","../src/hooks/getAbortController.ts","../src/hooks/useAbortController.ts","../src/hooks/useMounted.ts","../src/hooks/useImperativeAsyncTask.ts","../src/hooks/isAbortError.ts","../src/hooks/useLazyAsyncTask.ts","../src/hooks/useImmediateAsyncTask.ts"],"sourcesContent":["enum ActionType {\n  FAILED = 'FAILED',\n  STARTED = 'STARTED',\n  FINISHED = 'FINISHED',\n  SUCCEEDED = 'SUCCEEDED',\n}\n\nexport default ActionType;\n","import ActionType from './ActionType';\nimport type { Reducer } from './types';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst reducer: Reducer<any> = (state, action) => {\n  switch (action.type) {\n    case ActionType.STARTED:\n      return {\n        ...state,\n        pendingTasks: state.pendingTasks + 1,\n      };\n    case ActionType.FINISHED:\n      return {\n        ...state,\n        pendingTasks: state.pendingTasks - 1,\n      };\n    case ActionType.FAILED:\n      return {\n        ...state,\n        error: action.error,\n        result: null,\n      };\n    case ActionType.SUCCEEDED:\n      return {\n        ...state,\n        error: null,\n        result: action.result,\n      };\n    default:\n      throw new Error(\"An invalid action was dispatched to 'useTaskReducer'.\");\n  }\n};\n\nexport default reducer;\n","import type { State } from './types';\n\n/** Get the initial state for the store. */\nfunction getInitialState<Result>(): State<Result> {\n  return {\n    error: null,\n    result: null,\n    pendingTasks: 0,\n  };\n}\n\nexport default getInitialState;\n","/**\n * Get a new `AbortController` instance if the environment supports it.\n * Otherwise, it returns `null`.\n */\nfunction getAbortController(): AbortController | null {\n  if (typeof AbortController === 'undefined') {\n    return null;\n  }\n\n  return new AbortController();\n}\n\nexport default getAbortController;\n","import { useCallback, useLayoutEffect, useState } from 'react';\nimport getAbortController from './getAbortController';\nimport useMounted from './useMounted';\n\nexport type UseAbortControllerResult = {\n  abort: () => void;\n  signal: AbortSignal | null;\n};\n\n/**\n * React.js hook that provides the `AbortController` signal object and the\n * abort function.\n */\nfunction useAbortController(): UseAbortControllerResult {\n  const mounted = useMounted();\n  const [controller, setController] = useState(getAbortController);\n\n  useLayoutEffect(() => () => controller?.abort(), [controller]);\n\n  const abort = useCallback(() => {\n    if (!mounted()) return;\n\n    setController(getAbortController);\n  }, [mounted]);\n\n  return {\n    abort,\n    signal: controller?.signal ?? null,\n  };\n}\n\nexport default useAbortController;\n","import { useCallback, useLayoutEffect, useRef } from 'react';\n\nexport type UseMountedResult = () => boolean;\n\n/** React.js hook that provides a function to check if component is mounted. */\nfunction useMounted(): UseMountedResult {\n  const mountedRef = useRef(true);\n\n  useLayoutEffect(\n    () => () => {\n      mountedRef.current = false;\n    },\n    [],\n  );\n\n  return useCallback(() => mountedRef.current, []);\n}\n\nexport default useMounted;\n","import { useCallback, useMemo, useReducer } from 'react';\nimport type AsyncTask from './AsyncTask';\nimport isAbortError from './isAbortError';\nimport { ActionType, getInitialState, reducer, Reducer, State } from '../store';\nimport useAbortController from './useAbortController';\n\nexport type ImperativeAsyncTask<Result> = Readonly<{\n  error: Error | null;\n  result: Result | null;\n  pending: boolean;\n  executeTask: (task: AsyncTask<Result>) => Promise<void>;\n}>;\n\nfunction useImperativeAsyncTask<Result>(): ImperativeAsyncTask<Result> {\n  const { signal } = useAbortController();\n\n  const initialState = useMemo<State<Result>>(getInitialState, []);\n\n  const [state, dispatch] = useReducer<Reducer<Result>>(reducer, initialState);\n\n  const executeTask = useCallback(async (task: AsyncTask<Result>) => {\n    dispatch({ type: ActionType.STARTED });\n\n    try {\n      dispatch({\n        type: ActionType.SUCCEEDED,\n        result: await task({\n          signal: signal ?? undefined,\n        }),\n      });\n    } catch (error) {\n      if (isAbortError(error)) {\n        return;\n      }\n\n      dispatch({ type: ActionType.FAILED, error: error as Error });\n    } finally {\n      dispatch({ type: ActionType.FINISHED });\n    }\n  }, []);\n\n  const { error, result, pendingTasks } = state;\n\n  return {\n    error,\n    result,\n    pending: pendingTasks > 0,\n    executeTask,\n  };\n}\n\nexport default useImperativeAsyncTask;\n","import type AbortError from './AbortError';\n\nfunction isAbortError(error: unknown): error is AbortError {\n  // The environment doesn't support 'DOMException'.\n  if (typeof DOMException === 'undefined') return false;\n\n  if (error instanceof DOMException) {\n    return error.name === 'AbortError';\n  }\n\n  return false;\n}\n\nexport default isAbortError;\n","import { useCallback } from 'react';\nimport type AsyncTask from './AsyncTask';\nimport useImperativeAsyncTask from './useImperativeAsyncTask';\n\nexport type LazyAsyncTask<Result> = Readonly<{\n  error: Error | null;\n  result: Result | null;\n  pending: boolean;\n  executeTask: () => Promise<void>;\n}>;\n\nfunction useLazyAsyncTask<Result>(\n  task: AsyncTask<Result>,\n): LazyAsyncTask<Result> {\n  const { executeTask, ...state } = useImperativeAsyncTask<Result>();\n\n  return {\n    ...state,\n    executeTask: useCallback(() => executeTask(task), [task]),\n  };\n}\n\nexport default useLazyAsyncTask;\n","import { useLayoutEffect, useRef } from 'react';\nimport type AsyncTask from './AsyncTask';\nimport useLazyAsyncTask from './useLazyAsyncTask';\n\nexport type ImmediateAsyncTask<Result> = Readonly<{\n  error: Error | null;\n  result: Result | null;\n  pending: boolean;\n  executeTask: () => Promise<void>;\n}>;\n\nfunction useImmediateAsyncTask<Result>(\n  task: AsyncTask<Result>,\n): ImmediateAsyncTask<Result> {\n  const firstRenderRef = useRef(true);\n\n  const { error, result, pending, executeTask } = useLazyAsyncTask(task);\n\n  useLayoutEffect(() => {\n    executeTask();\n\n    return () => {\n      firstRenderRef.current = false;\n    };\n  }, [executeTask]);\n\n  return {\n    error,\n    result,\n    pending: firstRenderRef.current || pending,\n    executeTask,\n  };\n}\n\nexport default useImmediateAsyncTask;\n"],"names":["ActionType","ActionType$1","reducer","state","action","type","STARTED","__assign","pendingTasks","FINISHED","FAILED","error","result","SUCCEEDED","Error","getInitialState","getAbortController","AbortController","useAbortController","mountedRef","mounted","useRef","useLayoutEffect","current","useCallback","_b","useState","controller","setController","abort","signal","_a","useImperativeAsyncTask","_this","this","initialState","useMemo","useReducer","dispatch","executeTask","task","__awaiter","undefined","apply","_c","sent","DOMException","name","isAbortError","error_1","pending","useLazyAsyncTask","__rest","firstRenderRef"],"mappings":"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"}